Meeting on irc.gnome.org:#gtk-devel
Meeting started November 1 2004 17:03 EST (21:03 UTC)

In attendence: 

Anders Carlsson (andersca), Owen Taylor (owen), Jonathan Blandford (jrb), 
Manish Singh (yosh), Matthias Clasen (matthias), John Ehresman (jpe), 
Ray Strode (halfline), Robert Ögren (roboros), Maciej Katafiasz (mathrick), 
Carlos Garnacho Parro (garnacho), Tim Janik (rambokid), Tor Lillqvist (tml),
Jody Goldberg (jody)


<matthias>	looks like we're reasonably complete...
<matthias>	so, what do we have to discuss today ?
<jrb>	matthias: I had a date w/ vektor to discuss colors.  But I think we both forgot
<matthias>	jrb: maybe we can discuss the results next week...
<matthias>	jrb: ...or do you mean the meeting took place but both of you forgot the results ?
<jrb>	matthias: the meeting didn't take place.  I was more mentioning it in case others had interest in the topic
<matthias>	jrb: I would certainly be interested (we discussed it a bit already...)
<matthias>	owen: one thing I wondered about on the way home is the current status of Pango, and what your plans are for 1.8
<matthias>	owen: will 1.8 go out together with GTK+-2.6, and will it have the renderer changes necessary to support rotation ?
<owen>	matthias: Hmm, without GTK+ additions, the 1.6 => 1.8 changes don't really have a lot of point. 1.8 does add PangoRenderer, but I haven't done the work to support that in GTK+, which is fairly extensive and might conceivably require some PangoRenderer changes.
<owen>	matthias: So, there is some argument for backing that out and just do the planned script additions (tibetan, syriac, sinhala) for 1.8.
<owen>	matthias: I do want to do a 1.8 of some sort to go along with GTK+-2.6. Or I could stripstream the script additions into a 1.6.x dot release, but that's a little questionable.
<matthias>	owen: so no rotation in GTK+ 2.6 ? what GTK+ changes are necessary to support it ?
<owen>	matthias: If I don't have a new draft of the GTK+ changes for PangoRenderer by the meeting next week, I'd say it's no go for 2.6.
<owen>	matthias: Well, the API is tiny ... just gtk_label_set_angle() or something like that. But to maek that works requires porting GDK to PangoRenderer. There's a draft of that patch, but it isn't quite finished, and doesn't address GtkTextView.
<matthias>	owen: ok. 
<=> GtkTextView interface with derivation is something that is hard to predict without doign the GtkTextView work.
<owen>	matthias: I'll see if I can find some time in the next week to take another look and see how far away that is from being finished.
<matthias>	owen: probably not a good idea to do the pangorenderer changes if the higher layers are not done, and are likely to add new requirements...
<owen>	matthias: You mean to Pango? Yeah. That's why I'm thinking of backing it out of Pango if I don't get the GTK+ changes in for GTK+-2.6.
<matthias>	owen: although I think many people expect rotated labels in 2.6...
<owen>	matthias: Sigh, yes.
<matthias>	owen: maybe not rainbowcolored text set in spirals in a textview though...
<jrb>	matthias: jody is...
<owen>	I'll see what I can do. Have to tear myself away from luminocity and dri driver fixing.
Nov 01 17:16:28 *	matthias wouldn´t have problems to tear himself from the dri driver...
<matthias>	I have spent the last few days concentrating on docs, trying to get the 2.6 additions reasonably documented
<mathrick>	anything else on agenda? if not, I'd like to discuss http://lists.gnome.org/archives/gtk-devel-list/2004-October/msg00123.html a bit
<mathrick>	author couldn't make it here, as he's in GMT+5, but I was asked to proxy for him :)
<matthias>	mathrick: How different is that from the gobject-branch of libglade ?
<mathrick>	matthias: hmm, good question, didn't check that
<mathrick>	matthias: any informative url handy?
<owen>	mathick: Two comments a) Really should make sure we have rambokid before going into extensive discussion of gobject serialization  b) I tend to suspect this is something best developed for a whiel as an independent library
<mathrick>	owen: 1) yes, definitely, and jody too 2) quite reasonable
<mathrick>	owen: I'd add 3) to that, finish introspection first, at least do so before letting that in mainstream gobject
<owen>	mathrick: Oh, a third: c) Personally, I think widget state serialization (saving paned positions, treeview expansion, window sizes, etc.) would be a much more immediately useful activity. I don't think it's the same thing, though.
<mathrick>	owen: no, he was doing that for entirely non-widgetish gobjects AFAIK
<matthias>	owen: I think the two (object serialization vs state saving) are almost separate use cases
<owen>	mathrick: I agree with your 3) to some extent, I think it's first on the queue of major gobject additions. though probably doesn't h ave a lot of direct interference with this one way or the other
<mathrick>	owen: I want introspection stuff to have kind on .net-ish attributes support, that should influence any API heavily
<matthias>	owen: realistically, major gobject additions will be going nowhere if we rely on rambokid to review them - it takes anywhere between months and years to get him to review (relativly simple) bug fixes/optimizations...
<owen>	matthias: Well, he *claimed* to be going to have more time to work on GTK+. But yeah, he's pretty absent. But serialization is something he did a lot of work on in particular.
<owen>	mathias: For introspection, I think we should work on getting something we are happy with, then put the screws (;-) on rambokid to get it in.
<owen>	Or, if we are lucky, he'll have time to participate from the beginning.
<matthias>	owen: mitch was half-planning to drive to Hamburg with a box of beer to foster patch review...
<mathrick>	hi jody 
<jody>	good evening folks
<jrb>	hey jody
<mathrick>	jody: what would you expect from serialisation infrastructure supposed make you happy?
<mathrick>	matthias: I can't find anything meaningful on glade-gobject, that makes it rather hard to compare these two
<matthias>	mathrick: libglade has a cvs branch which supports non-widget objects
<matthias>	mathrick: http://cvs.gnome.org/viewcvs/libglade/?only_with_tag=libglade-gobject-support-branch
<mathrick>	matthias: do you know how complete was it meant to be? Are the GObjects targetted totally arbitrary, or need to be somehow special-cased for that?
<matthias>	mathrick: jrb would know more about it...
<mathrick>	jrb: ?
<matthias>	...since he wants to use it for tree model stuff.
<jrb>	mathrick: it was meant to be used just like the Widget stuff
<mathrick>	jrb: ie, you need to inform glade of any gobject you plan to use beforehand?
<jrb>	mathrick: that is, GObjects were supposed to be first class objects that you could get, but you still need the register the type
<jrb>	mathrick: yes, of course.  there's really no other way
<jrb>	unless you randomly look for _get_type symbols and hope that they work
<mathrick>	jrb: well, with full introspection, yes there is
<jody>	mathrick: to/from string operations for all of the common data types
<mathrick>	but for today, I guess there isn't
<jody>	and some of the utility functions in libglade
<mathrick>	jody: are multiple types needed / useful? or just bytestream is everything you want?
<jody>	I definitely need multiple types
<mathrick>	k
<jody>	mathrick: There should also be hooks to help versioning
<jody>	and hooks to handle renaming/retyping
<mathrick>	jody: yeah, I want versioning in together with introspection :)
<mathrick>	jody: retyping?
<mathrick>	retyping what?
<matthias>	mathrick: schema evolution in DB parlance...change the types of member between versions...
<mathrick>	ah
<mathrick>	so versioning with sugar on top, basically?
<mathrick>	hmm, can't remember if that was discussed, I think not... but how much of changes to how GTK+ is written for example would be acceptable to bring in introspection?
<matthias>	mathrick: you want to be able to deserialize from an older version into a newer one, and be able to influence how that is done...
<mathrick>	would IDL be acceptable solution?
<jody>	mathrick: retying == changing the type of an attribute
<jody>	eg you start with a 'line_width' as an int
<jody>	then make it a float a few versions later
<mathrick>	jody: yeah, I can see that now
<mathrick>	gah, it sucks that rambokid isn't here
<matthias>	mathrick: I can't see us rewriting gtk+ in IDL. It should be possible to add extra information necessary for introspection without rewriting all existing gobject based code...
<jody>	mathrick: a generic "here's a i/o context serialize all flagged properties" seems possible
<mathrick>	matthias: yeah, but what I'd like it to become is "typelib is authoritative", not headers
<owen>	mathrick: Lets
<owen>	's try to think of this as incremental
<mathrick>	matthias: so probably something like .h -> IDL -> typelib
<owen>	mathrick: I don't see why we can't keep .h authoritative for C based objects. 
<matthias>	mathrick: headers already say nothing about signals and properties... the class_init() registrations are authoritative for them....
<mathrick>	owen: because I want bindings to be first class citizens
<owen>	mathrick: if we have other objects that want to use other ways of maintaining their typelib, so they can do that
<owen>	mathrick: So?
<matthias>	headers basically define the C binding...
<mathrick>	matthias: yes, that's why I want to generate IDL from code once, and then work on IDL from there on
<owen>	matthias; i would say rather, that headers are the definition of objects implemented in C. 
<mathrick>	well, that doesn't necessarily mean IDL
<mathrick>	but amount of thing you need to stuff into C that aren't C anymore increases
<mathrick>	s/aren't/isn't/
<matthias>	owen: with IPN, the headers increasingly loose that role as well...
<mathrick>	I kinda dislike rpm headers cruft
<matthias>	err, s/IPN/IPD
<owen>	(Sidenote. I realized that I'm really not happy with how object properties are bound in C. I'm not sure if it's worth providing an alternate method)
<mathrick>	matthias: IPD == ?
<matthias>	mathrick: instance private data = private structs
<owen>	mathrick: I'm not saying that headers are *all* that is used to implement the object.
<mathrick>	ah
<jody>	mathrick: idl ? That seems like overkill
<mathrick>	owen: we want and really need to have .h 100% reconstructible from IDL
<owen>	mathrick: I don't see why
<matthias>	owen: what are you envisioning ? something more based on conventions, like java beans ?
<jody>	mathrick: I'd prefer to see a thin wrapper to get/set property
<owen>	matthias: No, setter/getter functions rather than the big switch.
<jody>	mathrick: good lord why ?
<mathrick>	owen: because I want to be able to define object in Py, and then inherit from it in C, call it, with no custom glue needed
<mathrick>	hmm
<mathrick>	s/IDL/typelib/ in the above
<mathrick>	IDL would be implementation detail of C code
<owen>	mathrick: Inherting C from Python is *hard*. I spent a day discussing that with hp once. I'm not sure it's worth trying to do.
<mathrick>	typelib should be the source of any type info
<mathrick>	owen: inheriting maybe not, but calling definitely
<matthias>	owen: stick the setter/getter in the paramspec ?
<owen>	matthias: I don't think that quite works because of, e.g., interfaces
<mathrick>	owen: it's saddening that we spend whole days discussing what languages are acceptable for libs and writing bindings from m-to-n languages
<mathrick>	owen: win32 has COM, they have no notion of bindings. COM is gross, but works
<owen>	But g_object_class_install_property(), g_object_class_override_property() could have variants that took a setter/getter as arguments
<mathrick>	so reference implementation of jabber was written in Delphi and noone had any problems with it
<owen>	mathrick: GObject is much less gross than COM from C. It's even less gross than COM from C++
<mathrick>	owen: I don't deny that :)
<owen>	mathrick: I don't think our goal should be be to reinvent the COM wheel... MS has largely moved on from that, after all.
<mathrick>	owen: also, in my Python code I can't really define full-fledged new types. To implement new TreeModel Py needs to have special hand-crafted GenericTreeModel to support that
<mathrick>	owen: COM is only one implementation
<mathrick>	what I want is real language transparency
<owen>	mathrick: Rather, our goal should be to solve the language binding problem ... to allow implementing an object in any language and binding it any interpreted language without compiled glue code.
<mathrick>	owen: exactly
<mathrick>	owen: that's my primary goal
<owen>	mathrick: Well, that's because PyGObject doesn't try to generically handle interfaces
<mathrick>	owen: because it can't, really
<mathrick>	owen: you cannot reliably override vmethods from Py
<mathrick>	owen: Py is still the best one when it comes to overriding C stuff
<owen>	mathrick: You coudl, with introspection information and something like libffi
<mathrick>	owen: that's what I want to do, yes
<jpe>	mathrick, given enough info, you could do interfaces in pygtk
<mathrick>	owen: but introspection needs info
<mathrick>	ie, typelib
<mathrick>	and *really* supporting bindings needs shifting responsibilities here
<jpe>	it seems to me that some sort of libffi is needed
<mathrick>	jpe: yes
<owen>	mathrick: Sure. But the typelib can still be a generated artifact from header files and classic gobject properties
<mathrick>	owen: no
<owen>	mathrick: Why not?
<mathrick>	owen: you need to be generating .h from typelib
<owen>	The typelib, *for objects implemted in C*
<owen>	Why?
<mathrick>	owen: since if I implmement some PyFooObject, I add that to typelib
Nov 01 18:01:42 *	owen goes into 3-year-old mode :-)
<jpe>	and then we can determine what info the ffi needs and what is the best way to supply it
<owen>	mathrick: It doesn't have to work the same for obejcts implemented in C and objects in python
<mathrick>	to access from C, you need to generate headers *from* typelib
<mathrick>	owen: it should
<matthias>	mathrick: typelibs for python objects would obviously not be derived from headers...
<owen>	mathrick: Why should it?
<mathrick>	owen: I don't want to differentiate between C and anything else
<mathrick>	it's artificial
<owen>	mathrick: I do. Because C doesn't look much like python.
<matthias>	mathrick: well, the languages are different
<mathrick>	owen: but we can support both
<jpe>	I think C objects should define their interface in C source files
<owen>	mathrick: In python, I have all these wonderful introspection, dynamic object creation, etc, facilities. That I can use to easily bind to something defined with a typelib
<mathrick>	owen: I want to do my best to make Python exactly as good citizen as C
<mathrick>	owen: yup
<mathrick>	owen: and I want to use that from C just as if it were written in C
<matthias>	mathrick: if you force everybody to use idl, there is no c anymore... at least from a C programmers perspective...
<owen>	mathrick: That doesn't mean making the C object definition process worse or more complicated. Or even different - a danger since we huge piles of GObjects already around
<mathrick>	owen: that should really go into `pkg-config --cflags gobject foopylib`
<mathrick>	matthias: now we also have IDL of a kind, just less convenient
<owen>	mathrick: Using python objects from C would be a cool goal, and maybe we can enable it, but it shouldn't be the primary goal of the introspection work or drive the overalll outline
<mathrick>	matthias: and IDL is only detail
<jpe>	I don't think idl files or xml files need to be or should be required
<mathrick>	matthias: what really matters here is that typelib rules, no headers
<matthias>	jpe: how do you envision filling in the typelib information, then ? 
<mathrick>	owen: uh, not having that now sucks enough. I want next iteration to have all the cool features possible right from beginning
<jpe>	mathrick, I think for C objects you go from .h files to the typelib
<mathrick>	jpe: yes
<mathrick>	jpe: but arbitrary is still typelib
<owen>	mathrick: You stiill haven't explained why having idl be canonical for python objects and having header files be canonical for C objects doesn't work fine
<jpe>	for Python files you go from .py to the typelib
<jpe>	idl isn't needed for python either
<mathrick>	owen: because that wouldn't work for python
<mathrick>	owen: python is too dynamic
<mathrick>	owen: so it all should happen as I type, really
<owen>	jpe: (There is some argument for making IDL files canoncial for python ... python isn't strongly typed, it doesn't have interfaces, etc)
<jpe>	the typelib is just an implementation detail that provides the info needed for libffi
<mathrick>	owen: if I open up interactive python session, I have no IDL at the beginning. If I define some gobject in the meantime, it should show up in typelib right away
<owen>	mathrick: I'm sorry, why doesn't it work for python? How does python care if someone typed in a IDL file or typed in a header file for the C object
<jpe>	owen, I agree you want to better define the interfaces in python, but I'd suggest doing it in python
<owen>	mathrick: Umm, there is no global type library for the system that is dynamically updated. Interfaces repositories in my experience are a horrible idea.
<mathrick>	owen: uhh, slower, I can't type fast enough ;)
<jpe>	I agree, the idea shouldn't be to export python's full dynamism into C
<owen>	mathrick: But if you want to enable using python objects for C, you have to  accept the fact that python objects can't be changing their methods on the fly.
<mathrick>	owen: yes, I can see that
<jpe>	most Python objects don't change their methods
<owen>	mathrick: Because the C objects (to preserve any sort of C interface that isn't the worlds most horrible interpreted language) need to be compiled against a header file generated based on a fixed typelib.
<mathrick>	owen: but that shouldn't matter for how Py programmer *writes* his code, just how that code works
<mathrick>	owen: and Py program starts with no custom classes, all the types are defined at runtime. There's no reason not to generate that info at runtime for GObject too
<jpe>	mathrick, the C programmer will probably generate a proxy lib from info in the typelib and then compile it
<owen>	mathrick: I haven't looked at PyORBit a lot, but if it's like CORBA::ORBit it may be a good model for implementing defined interfaces from an interpreted language.
<mathrick>	owen: Py runtime can take care of doing all that
<mathrick>	owen: yes, I had a talk with michael and jamesh, and more will follow
<mathrick>	jpe: yes, that's the plan
<owen>	mathrick: If you dont' care about export to compiled languages, sure. But if you do care about export to compiled lanugages, then you need a *fixed* typelib, not a runtime-generated typelib.
<jpe>	only what is defined when the proxy lib is generated will be available
<mathrick>	owen: these two don't conflict :)
<mathrick>	owen: if python can work out all the types at runtime, that means it's enough info to work. Why should that be harder than typelib.save() to fixate that?
<owen>	jpe: You can actually get away without a proxy lib with some magic.    #define gtk_widget_show(w) (void (*) (GtkWidget *))((GenericObject *)w->vtable[53])(w)
<owen>	mathrick: Basically, because I believe it makes for bad python development workflow.
<mathrick>	owen: the system should probably have multiple typelibs chunks, merged into one global typelib by kind of linker
<jpe>	most likely what will happen is that there will be well defined interfaces that both .py and .c code will know about
<owen>	mathrick CORBA::ORBit is almost   "import foo.idl"
<mathrick>	owen: uhh, that *is* python workflow
<owen>	mathrick: I don't see any reason to have a global typelib.
<mathrick>	owen: global for given process
<mathrick>	not any registry or anything
<owen>	mathrick: Python isn't smalltalk. Most people continually start their apps from scratch.
<owen>	mathrick: Ther eisn't some sort of workspace concept where you rejoin a workspace, modify the code.
<owen>	(That was a common paradigm in time sharing days. APL worked like that. Smalltalk I think mostly works like that)
<mathrick>	owen: uh-oh, you lost me now
<mathrick>	owen: I don't see what is your objection here
<owen>	mathrick: I'm saying, to make changes to my python code, I edit the code, restart the program
<mathrick>	owen: yes
<jpe>	owen, you're right about Python v Smalltalk
<matthias>	owen: yes, smalltalk works like that
<owen>	mathrick: So I could edit the IDL file and restart the program too, if I wanted to change the definition of an interface
<owen>	mathrick: Having to run my program in some special 'dump the typelib' mode seems backwards to me.
<mathrick>	owen: umm, a bit of apples and oranges here :)
<mathrick>	owen: lemme explain
<mathrick>	owen: I mean, Python starts app with clean slate -- it knows of no types besides builtins
<jpe>	owen, I think the more useful python example is defining an object that supports an interface that is already well known
<mathrick>	owen: so almost everything you defing means kind of patching Py's typelib at runtime, right?
<mathrick>	s/defing/defining/
<mathrick>	owen: now, in fact GObject also works that way
<mathrick>	in binary on disk, it knows no types
<mathrick>	all happens at runtime
<jpe>	owen, you could bring in the .idl file or you could just use the typelib's api directly
<owen>	mathrick: I think the word "typelib" is being used a little confusingly here. But yes, the registry of types is built up at runtime
<jpe>	mathrick, pygtk doesn't quite do everything at runtime
<mathrick>	owen: so, what really is different between GObject-from-C and GObject-from-Py is that C demands to know definitions beforehand, which you need to supply
<owen>	mathrick: The point I'd make though is that in order to use a python object from a compiled language, we need an on disk representation of the type of that object. An in memory representation isn't enough
<matthias>	sorry guys, I have to leave this very entertaining discussion now...see you later
<mathrick>	cya matthias 
<owen>	matthias: later
<mathrick>	owen: yes, but that's technical detail for now, we can safely leave that alone for a minute
<owen>	mathrick: I think it's a very important technical "detail" that implies a lot about how things should work from python
<mathrick>	owen: yes, I'll get back to it in a minute
<mathrick>	owen: now, Py is dynamic, so it has no problem with supplying GObject at runtime with type info it learns as it goes
<mathrick>	owen: so, there is no reason for both Py and GObject themselves to insist on having any sort of fixed representation -- so far no C exists yet
<owen>	mathrick: Sure. Though providing GObject with data requires providing it a lot more than python normally has. (Which I'll get back to in a moment)
<mathrick>	owen: suppose there is piece of C code that manipulates some GFooInterface
<mathrick>	owen: now, I can implement that iface in Py, pass the implementor to C, have it do its job, with no fixed representation in the process
<mathrick>	so IDL here would be superficial
<mathrick>	there is one special case
<owen>	mathrick: Sure, *if the iface* is originally defined in C with a header file.
<mathrick>	where we need to use info from dynamic language in a static language
<mathrick>	owen: but still, the typelib here is who knows everything about types, IDL is still not necessary to generate headers for C
<mathrick>	IDL is only textual representation of info typelib stores
<mathrick>	owen: so, we don't really need IDL, as long as we provide some way to dump typelib into persistent form
<owen>	mathrick: Sure. it's really a workflow issue. There's no reason it couldn't be done with a PyObject.writetypeLib()
<mathrick>	owen: it may turn out that IDL is really the most convenient, but that we will see
<owen>	mathrick: But in order to have an object interface usable from multiple languages, we need to have a good concept of stability. Of an idea that it *is* an interface.
<mathrick>	owen: yes
<mathrick>	owen: but that comes only from different conventions used in languages, not from the fact that C is better than Python. I want situation where there is exactly no difference between the two, as far as GObject is concerned
<owen>	Doing that with PyObject.writeTypeLib() just seems pretty inconvenient to me as opposed to an IDL, because Python code isn't really structured around interfacse
<mathrick>	owen: so everything that remains is different workflow
<owen>	If there were python header files, that might be a quite different thing
<mathrick>	owen: I think we could even do that using the type info itself
<mathrick>	owen: just as there could be Serializable attribute
<mathrick>	there could be FixatedType attribute you could supply
<owen>	mathrick: But in order to use the 'type info' to generate a type lib, I have to have some way of getting my program to run in a special mode where it registers all its types and dumps them to a file. Ugh.
<mathrick>	so Python would see that and automatically dump info
<jpe>	owen, it might be possible to come up with a reasonable interface to do it all in python
<mathrick>	owen: that's no different from running "generat-py mylib.tlb" :)
<mathrick>	owen: my point is, it is possible to do somehow, we will see what is the most practical way
<owen>	jpe: Sure, there could be conventions, etc. But considering that defining strongly typed interfacse in Python is horrid (look at how GObject signals work). I tend to think a typelib would be nicer
<owen>	mathrick: Oh, I'm not suggesting generate-py mylib.tlb That's dreadful.  I'm suggesting 'import mylib.tlb'
<mathrick>	yay, rambokid 
<rambokid>	hey
<jpe>	a lot of modules only define classes and functions, so running a utility to import the module and inspect it might be reasonable
<owen>	mathrick: Anyways, where we *started* here wasn't arguing for IDL files for Python. But against IDL files for C.
<mathrick>	rambokid: just when we have most typing intensive stuff already discussed :>
<mathrick>	rambokid: I hate you :P
<rambokid>	mathrick: thank you ;)
<mathrick>	owen: yes
<owen>	mathrick: We should start of f from whatever is most convenient for a particular language, and generate a typelib file (ELF chunk, etc) from that.
<carol>	mathrick: hush, i told him the meeting and plans involved beer
<mathrick>	owen: IDL would be pure tradeoff for C
<mathrick>	carol: hehe
<jpe>	owen, I use a metaclass to make defining signals easier and while it is clunky, it beats having a separate IDL file
<mathrick>	owen: yeah
<mathrick>	owen: question here is -- do we want to embed all the stuff in .h and .c, or do we decide it's too kludgy and move to IDL?
<jpe>	owen, and python will grow type annotations over time
<owen>	mathrick: We can easily have a system where we have  'IDL => typelib'  'typelib => IDL'   'header => typelib' and use header files as the authorative source for gobject implemented objects.
<mathrick>	owen: IDL would be question of convenience here
<owen>	mathrick: Someone is free to have gob3/gmoc. But I'm pretty positive we won't wnat to go that route for GTK+
<jpe>	mathrick, as someone who used .idl files with a CORBA orb, do everything in .c & .h
<mathrick>	owen: well, I want to get it to the state where .h files can be 100% accurately regenerated from typelib
<owen>	jpe: Hmm, from what I've seen, attempts to introduce tpye annotations into python have been pretty uniformtly shot down
<mathrick>	owen: since, regardless of what is generated from what, typelib should be _the_ source
<mathrick>	owen: of course, typelib can be generated from .h
<owen>	mathrick: that's not going to happen for C objects. Sorry. I think we can lay that down as a groundrule for this work.
<jpe>	owen, Guido is reserving some keywords for it and has implied it will eventually be added
<jpe>	owen, there's no timeline for it, though
<owen>	mathrick: For one thing, did you see my "object-file-less header file trick above" ? (based on XPCOM, actually)
<mathrick>	owen: if I make my KillerPyLib, you're going to generate from typelib ;)
<mathrick>	owen: what trick, no?
<owen>	jpe: You can actually get away without a proxy lib with some magic.    #define gtk_widget_show(w) (void (*) (GtkWidget *))((GenericObject *)w->vtable[53])(w)
<jpe>	I saw something in the ctypes documentation that there's a way to get type info out of gcc
<mathrick>	owen: ah, yeah
<owen>	mathrick: If you do that for your generated header files, you don't want your C-implemented-header files to be at all like that. You want to call the real C methods, not some vtable proxy.
<mathrick>	owen: yup
<mathrick>	owen: I think it's going to work that way
<owen>	mathrick: typelib isn't the authoritive source. It's the authoritative way to exchange type information
<mathrick>	owen: it's meant to be 110% compatible with today's GObject
<mathrick>	owen: yeah, that definition is more precise
<owen>	mathrick: The authoritative source is whatever works best for the person defining the Object. For GTK+, that's header files.
<owen>	(We may have a gmoc change of heart. It's conceivable. But for now, I'd bet against it.)
<mathrick>	owen: I don't insist on gmoc happening. I want gmoc to be fully feasible if we decide it's too much burden to write endless /* @methodof@ */ stuff
<rambokid>	owen: beast kinda does that with its own idl compiler. that thing is very flexible and implements 99% of the non signal-processing stuff for plugins.
<rambokid>	it'd be too specific and non-standard i guess for adoption though.
<owen>	mathrick: I think by making parsing smart about how GObjects normally work ... like gtk-doc is smart .. I don't think we'll have as much annotation as you expect.
<mathrick>	rambokid: mental note to look into it added :)
<rambokid>	http://beast.gtk.org/sfidl-manual.html
<mathrick>	owen: yeah, that's to be evaluated in practice I guess
<rambokid>	http://beast.gtk.org/plugin-devel.html
<rambokid>	both documents are still being worked on though
<owen>	mathrick: But sure, anything that allows object definition without header files for other languages can be used with gmoc style approach.
<rambokid>	owen: is gmoc a vapourware term for gobject-moc or did someone start such a thing already?
<mathrick>	rambokid: vapourware
<owen>	rambokid: It's purely a vaporware name. for gobject-moc / gob-future
<mathrick>	we should name it "mob" :)
<mathrick>	moc + gob
<owen>	mathrick: Except that gob is sort of (but not really) moc + gobject already
<mathrick>	owen: yeah, it's elaborate cpp, I know
<rambokid>	really i think, GObject got very far in using C. when ading (much) more sugar/functionality to it though, i think the language situation should be reevaluated, i don't see much point in going very much farther in C if C++ is ubiquitously available.
<owen>	mathrick: gob (last time I looked) is a bit more like cfront because you define your object implemetnations not the just the interface.
<owen>	rambokid: C++ isn't much of an advance from C. 
<mathrick>	rambokid: C++ sucks
<jpe>	you really want to go to C++?
<mathrick>	rambokid: no matter if it is ubiquitous or not
<rambokid>	by means of conventions, C++ can be just as easily bindable as C and it can integrate with the GObject framework well.
<owen>	rambokid: As faras type systems go. After all, you need moc, or libsigc++, or whatever to make it a decent object system
<mathrick>	rambokid: in terms of type system, C++ == C, ie almost non-existant
<rambokid>	owen: if you say that, you haven't actually tried to grasp the concepts behind that language, "The C++ Programming Language" by bjarne would e.g. be a good guide for that.
<owen>	rambokid: I'm definitely in the managed runtime camp as far as long term direction. What I'd like to see short term is just a good full introspection system for GObject so that we can export GObjects to interpreted languages or to a managed runtime without code generation or manual binding glue
<mathrick>	rambokid: I think I did, and I still hold that C++ has no real type system
<owen>	rambokid: I spent several years programming C++ before I ever wrote pure C program
<rambokid>	mathrick: i said ubiquitous since when gtk+ started out, C++ wasn't an option in practice, due to changing standards and lacking cimplementations
<mathrick>	rambokid: that's orthogonal
<rambokid>	owen: the interesting concepts became aparent only in recent years
<mathrick>	rambokid: C++ isn't sufficient for what we need and want it, and introspection stuff will only strengthen that discrepancy
<owen>	rambokid: While some of the C++ syntatic sugar could have been useful for GTK+/GObject, I want events, I want introspection, I want garbage collection, I want properties.
<rambokid>	mathrick: practical considerations are never orthogonal if you intend to actually get something done ;)
<mathrick>	owen: exactlt my view (on managed thing)
<mathrick>	rambokid: C++ sucks, GObject doesn't, and it actually works
<owen>	rambokid: All of that stuff isn't in C++ without a thick layer on top. And I don't see any reason to move in that direction when better alternatives are available.
<mathrick>	rambokid: C++ doesn't buy us a thing over GObject
<mathrick>	rambokid: since they operate in totally different domains
<rambokid>	owen: i've tried various introspectable procedure (function) things in beast over the years, and i don't really think there're good ways to get it done conveniently without either templates or code generation.
<owen>	mathrick: I'm not sure I'd say that. I would agree that they are largely orthogonal axes.
<mathrick>	owen: I mean, switch to C++ doesn't invalidate need to have GObject on top, so C++ doesn't buy us a thing
<mathrick>	we still need to do that work
<rambokid>	owen: if with managed runtime you mean apps working in a mono-like runtime-env long-term, yes, i'd second that.
<rambokid>	mathrick: C++ provides wonderfull tools to implement introspection.
<mathrick>	owen: and I personally come to hate C++
<mathrick>	rambokid: like?
<owen>	rambokid: Despite not having types as first class objects?
<rambokid>	mathrick: "Hate" is hardly ever a valid arguemnt
<mathrick>	rambokid: I _come_ to hate it
<mathrick>	rambokid: I started as fanboy, after reading Stroustrup
<mathrick>	didn't really even know C at tge time
<owen>	rambokid: (OK, that's changed a bit recently with RTTI, but it's still very weak in the introspection realm. In C# or Python you can iterate the methods of a class and call them without generating any code)
<mathrick>	rambokid: what are the tools you have in C++ that aren't there in C?
<mathrick>	rambokid: I mean tools that are useful for anyone else than C++ code that is
<rambokid>	note that i'm not really advocating replacing GType/GObject with C++ here. i just don't think with hand-crafted type+object+signal stuff in C you can get a certain distance and after that things just become too inconvenient.
<mathrick>	rambokid: then we can switch to more elaborate language, like Python
<owen>	rambokid: anyways, I'm hoping that we can figure out introspection for current gobjects with header file annotation and analysis. We already do most of that with gtk-doc, and the various language binding header scanners already. If we can't, well, then we'll reevaluate.
<mathrick>	rambokid: GObject is really only a runtime
<rambokid>	and i think GObject explores most of what's possible in that, so we shouldn't go much farther. large code-gen macros like G_DEFINE_TYPE() are a typical symptom at this point. we're close enough to wanting a moc to stay convenient enough.
<mathrick>	hmm, related question: how good is libffi at portability and workingness on platforms we support?
<rambokid>	mathrick: yes, because there's no way to implement GObject with static typing in C.
<rambokid>	mathrick: it wasn't good enough when i wrote GSignal.
<jpe>	rambokid, you may be right about GObject based C code is complex, but C++ probably isn't much better
<mathrick>	rambokid: hmm
<rambokid>	mathrick: but nowadays they ship it with gcc for java, so i'd expect it to get good enough if it isn't already. 
<owen>	rambokid: My general feeling is we should work on making GObject introspectable, because that works well for any way we should go forward. but no, it's never going to allow the programmer on the street to easily write OO programs.
<mathrick>	rambokid: that was when? 8 years ago?
<mathrick>	rambokid: ah, ok :)
<rambokid>	mathrick: it's not necessarily as fast as our current (optimized) marshallers though.
<owen>	rambokid: And it is never going to be blazingly efficient. 
<mathrick>	rambokid: yeah, but libffi is here for thunks we'd need to be generating for bindings
<owen>	rambokid: I do sometimes wonder if libffi could be *more* efficient because it doesn't have big wads of generated code to foul up l1 caches
<owen>	rambokid: And at least optionally having marshaller == NULL use libffi could make signal-definition-for-novices easier
<rambokid>	owen: as for .h file analysis, i've never liked putting semantic app information into comments. the enum nicks are already a stretch. so at that point i (personally) rather turn to a different language (like porting beast to C++)
<owen>	rambokid: (I can get glib-genmarshal going in  Makefile in 30 seconds flat. But that's not typical)
<rambokid>	jpe: i'm not even saying code with GObject is necessarily complex, but definitely clumsy and inconvenient to write. thus people do much less derivation than would be usefull for the problem domains, and you start to see crutches like G_DEFINE_TYPE() pop up.
<mathrick>	rambokid: but that's purely C's trait, not GObject's
<rambokid>	owen: right (about not esily writing OO)
<mathrick>	rambokid: I can do class Foo(gobject.GObject): easily
<rambokid>	mathrick: the cause doesn't matter if the effects keep us from doing good OO ;)
<mathrick>	rambokid: and that's why I asked if that would be acceptable to use IDL for C, some time before you joined :)
<rambokid>	mathrick: no, gtk(+) was 8 years ago, GSignal was around 2000/2001 iirc
<owen>	(as long as you don't forget to chain up the constructor and get a mysterious crash deep in PyObject C code. But maybe that is fixable with metaclass)
<rambokid>	maybe some of 2002, when did we release 2.0?
<owen>	rambokid: Mar 2002. Gobject was first half of 2001 mostly
<jpe>	rambokid, I agree (which is why I use python); to make C++ work requires a fair amount of work and the results are only usable by those who know the particular dialect of C++
<mathrick>	owen: that's general weakness (or strength) of python's class model
<jpe>	owen, the need to chain up is fixable
<rambokid>	owen: as for caches, lots of marshallers bloat apps, yes. but in practice only a small amount of them gets used, so usually there's not too much marshalling code to be kept in caches (as far as my experiences go)
<rambokid>	owen: yes, marshaller==NULL falling back to something like libffi was mentioned pre-GSignal, and i if i'm not mistaken, the GSIgnal API should allow for such an extension.
<mathrick>	when is 2.6 scheduled as of today?
<mathrick>	dec 15?
<rambokid>	owen: yep, i can derive a new object in a couple minutes with a good skeleton of functions i need in place. the point is, most other people can throw around GObject code/rule like us ;)
<rambokid>	s/most other people can/most other people cannot/
<rambokid>	i hope i didn't completely ruin the discussion you all had when i joined... ;)
<jpe>	rambokid, I think the situation w/ C++ GObject would be worse than it is now
<mathrick>	rambokid: no, we were summoning you from beginning :)
<owen>	rambokid: No, it was tailing off. Actually, originally we were looking for your for GObject serialization discussion. But that got sidetracked into introspection, and it's 2 hours later now, so probably about it for this meeting :-)
<rambokid>	mathrick: someone should have /msg'ed me then. there's always a good chance i'm near the machine...
<mathrick>	rambokid: ah, I quickly scanned channels and you were on none, didn't think of it
<rambokid>	i'm not vey fond of the serialization discussion. i'm reading it on the list, but from all i figured about object serialization over the last 5-7 years, it is *very* application specific. i could list like 5-10 points off head that'd be missed by a generic implementation (and interface even) in glib.
<rambokid>	mathrick: #gtk+ ?
<mathrick>	rambokid: joined 1h after discussion started :)
<rambokid>	[rambokid] #mono @#gimp #beast @#gtk+ @#gnome-hackers @#gnome #gnome-de #commits 
<rambokid>	mathrick: no, i'm on all these channels all day long. i just rejoin from time to time due to ppp reconnections
<mathrick>	rambokid: ah, right, so I missed you there
<rambokid>	anyway ;)
<mathrick>	bad thing is, I need to get my ass moving on that introspection thing, discussing is nice, but doesn't get things done :|
<mathrick>	(which is kinda sad ;)
<mathrick>	rambokid: hmm, still here?
<rambokid>	yes.
<rambokid>	(i ought to be in bed already though ;)
<mathrick>	rambokid: there's ongoing discussion on #gstreamer, and Company is mumbling about not being able to unregister type
<mathrick>	rambokid: is it possible to do?
<mathrick>	and if not, would it be possible to add unregistering?
<rambokid>	no.
<mathrick>	no for both?
<owen>	mathrick: no, very hard, we decided against it during GObject design. (OK, I think rambokid explained to me how hard it was and why he wasnt' going to add it)
<rambokid>	no for unregistering, what's the other issue?
<mathrick>	rambokid: 1) is that possible now? 2) can that be added? were the issues :)
<rambokid>	mathrick: company has unloading and library-dependancy problems. he doesn't really have gtype problems.
<mathrick>	rambokid: no, he wants to be able to totally remove types
<rambokid>	mathrick: ok, then no on both ;) as owen said, it was a design decision.
<rambokid>	mathrick: basically, there's no point in removing type ids.
<rambokid>	mathrick: i talked to company the other day on irc, just him thinking he needs type id removal doesn't mean this would solve the problems he's facing.
<mathrick>	rambokid: ic
<mathrick>	rambokid: well, I can see that useful in arch so much plugin-oriented as gst
<rambokid>	mathrick: it is not. type id removal would basically mean two things:
<rambokid>	1) existing type handles become invalid (that's as good as "unregistering" quarks)
<rambokid>	2) you couldn't reload a dynamic type.
<rambokid>	(1) doesn't buy you anything, and (2) canbe done by convention.
<mathrick>	yeah, but (2) needs code, which would reside in libgstreamer, which we want unloaded. That's the Company's concern if I got it correctly
<owen>	mathrick: You can unload all code associated with a type ... the main thing you can't do is reuse the same type name with a different object heirarchy
<rambokid>	mathrick: you are aware that type implementation unloading (objects, interfaces...) *is* supported by GType?
<mathrick>	rambokid: yes
<rambokid>	mathrick: then i don't understand what code you want to unload but can't
<rambokid>	i know what company's problem is though. he's got plugins that need third party libs that may or may not be unloadable and may or may not need intitialization or be already initialized. (kinda like using libgtk from within a plugin only)
<mathrick>	rambokid: hmm, I think it goes like that: we load type plugin, register dynamic type. it's completed at some point. then we unload it, and want g_type_plugin_complete_type_info() to fail from now on. But to know if / when to fail, we need bookkeeping code, which is a drag, and also that code can reside in unloaded lib
<owen>	mathrick: I think the thread safety flaws in gobject would be a much more interesting windmill to tilt at ;-)
<owen>	for gst
<mathrick>	heh
<rambokid>	g_type_plugin_complete_type_info() can't fail.
<rambokid>	owen: oh, i desperately want atomic refcounts, just too little time...
<rambokid>	mathrick: i don't even know what "g_type_plugin_complete_type_info() fails" could possibly mean, other than: "the program is broken, bail out".
<mathrick>	rambokid: hmm, so can you fail to reload dynamic type?
<rambokid>	no, the type system guarantees the caller that he'll also gets the type he requests (e.g. g_object_new() cannot fail)
<rambokid>	s/also/always/
<mathrick>	rambokid: right, and Company wants to be able to fail
<mathrick>	ie, when we load plugin, we don't want to commit to that type being available forever
<rambokid>	mathrick: i guess you could create wrapper code for g_object_new() that can check and fail.
<rambokid>	that wouldn't work for say widgets which use g_object_new() internally, but for all places where you call your wrapper constructor. you need to write your own creation code anyway since it needs to be able to handle failing object creation then.
<rambokid>	(as an aside, libgtk widgets are static types anyway)
<mathrick>	rambokid: yeah, it's not like we want arbitrary types to disappear, but our plugins should be completely unloadable
<mathrick>	and leave no traces
<rambokid>	mathrick: "unloadable" is the wrong term
<mathrick>	rambokid: s/unloadable/whatever is right/ then :)
<rambokid>	mathrick: the type system can't allow for that. say you load plugin A introducing Foo and then some code derives Bar from Foo (or uses values/pspecs with type Foo etc.)
<rambokid>	so once Bar (or the related values/pspec/etc code portions) is used, Foo must be reloadable. full removal of it would break sorta unrelated code portions. (at least from a type system API perspective)
<mathrick>	rambokid: in general case yes, but if you use such removable type, you should be aware of consequences :)
<rambokid>	mathrick: no. if that were the case, plugin types couldn't be used the same way static types are.
<rambokid>	i.e. you suddenly had to query is_plugin(type) before doing g_object_new(type) and check for NULL (or check for NULL from g_object_new() everywhere).
<rambokid>	this special casing were explicit non-goals in the gobject design (partly due to GtkObject), and is what i suggested earlier you add around your gstreamer types only.
<mathrick>	yeah, I guess so
<mathrick>	anyway, it's 2AM
<mathrick>	I should be sleeping :)
<rambokid>	(it's not just g_object_new() though, as i mentioned earlier, there're values, signals etc. that use type ids)
<rambokid>	me too, need to get up at 8. night.
<mathrick>	nite


Meeting ended November 1, 20:04 EST (00:04 UTC)

